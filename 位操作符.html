<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 1. 按位非
        // 按位非操作符用波浪符（~）表示，它的作用是返回数值的一补数。按位非是 ECMAScript 中为数
        // 不多的几个二进制数学操作符之一。看下面的例子：
        // let num1 = 25; // 二进制 00000000000000000000000000011001
        // let num2 = ~num1; // 二进制 11111111111111111111111111100110
        // console.log(num2); // -26
        // 总结: 取反 -1

        // 2. 按位与
        // console.log(25 & 3); // 1
        // 25 和 3 的按位与操作的结果是 1。为什么呢？看下面的二进制计算过程：
        //  25 = 0000 0000 0000 0000 0000 0000 0001 1001
        //   3 = 0000 0000 0000 0000 0000 0000 0000 0011
        // ---------------------------------------------
        // AND = 0000 0000 0000 0000 0000 0000 0000 0001
        // 总结：上下两数 为都1 最终为1，否则最终为0

        // 3. 按位或
        // console.log(25 | 3); // 27
        //  25 = 0000 0000 0000 0000 0000 0000 0001 1001
        //   3 = 0000 0000 0000 0000 0000 0000 0000 0011
        // ---------------------------------------------
        //  OR = 0000 0000 0000 0000 0000 0000 0001 1011
        // 总结：上下两数 都为0，则最终为0，否则为1，与 按位与相反

        // 4. 按位异或
        // console.log(25 ^ 3); // 26
        //   25 = 0000 0000 0000 0000 0000 0000 0001 1001
        //    3 = 0000 0000 0000 0000 0000 0000 0000 0011
        //  ---------------------------------------------
        //  XOR = 0000 0000 0000 0000 0000 0000 0001 1010 
        // 总结：上下两数如果都为0 || 1，则为0，否则为1

        //  5. 左移
        //  左移操作符用两个小于号（<<）表示，会按照指定的位数将数值的所有位向左移动。比如，如果数值 2（二进制 10）向左移 5 位，就会得到 64（二进制 1000000）

        // 6. 有符号右移
        // 有符号右移由两个大于号（>>）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）。有符号右移实际上是左移的逆运算。比如，如果将 64 右移 5 位，那就是 2

        // 7. 无符号右移
        // 无符号右移用 3 个大于号表示（>>>），会将数值的所有 32 位都向右移。对于正数，无符号右移与有符号右移结果相同。仍然以前面有符号右移的例子为例，64 向右移动 5 位，会变成 2
        // 对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会给空位补 0，而不管符号位是
        // 什么。对正数来说，这跟有符号右移效果相同。但对负数来说，结果就差太多了。无符号右移操作符将
        // 负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变
        // 得非常之大，如下面的例子所示：
        // let oldValue = -64; // 等于二进制 11111111111111111111111111000000
        // let newValue = oldValue >>> 5; // 等于十进制 134217726

    </script>
</body>

</html>